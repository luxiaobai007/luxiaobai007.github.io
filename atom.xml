<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://luxiaobai.cn/atom.xml" rel="self"/>
  
  <link href="https://luxiaobai.cn/"/>
  <updated>2021-10-11T02:14:06.310Z</updated>
  <id>https://luxiaobai.cn/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis6入门学习(三)</title>
    <link href="https://luxiaobai.cn/2021/10/11/redis/Redis3/"/>
    <id>https://luxiaobai.cn/2021/10/11/redis/Redis3/</id>
    <published>2021-10-11T01:54:21.539Z</published>
    <updated>2021-10-11T02:14:06.310Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Redis-Jedis-测试"><a href="#Redis-Jedis-测试" class="headerlink" title="Redis_Jedis_测试"></a><strong>Redis_Jedis_测试</strong></h1><h2 id="Jedis所需要的jar包"><a href="#Jedis所需要的jar包" class="headerlink" title="Jedis所需要的jar包"></a><strong>Jedis所需要的jar包</strong></h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="连接Redis注意事项"><a href="#连接Redis注意事项" class="headerlink" title="连接Redis注意事项"></a><strong>连接Redis注意事项</strong></h2><p>禁用Linux的防火墙：Linux(CentOS7)里执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop/disable firewalld.service </span><br></pre></td></tr></table></figure><p>Redis.conf中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure><h2 id="Jedis常用操作"><a href="#Jedis常用操作" class="headerlink" title="Jedis常用操作"></a><strong>Jedis常用操作</strong></h2><p><strong>测试程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectRedis</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        String pong = jedis.ping();</span><br><span class="line">        System.out.println(<span class="string">&quot;连接成功&quot;</span> + pong);</span><br><span class="line">        <span class="comment">//测试相关数据类型</span></span><br><span class="line">        <span class="comment">//Key</span></span><br><span class="line">        jedis.set(<span class="string">&quot;k1&quot;</span>,<span class="string">&quot;v1&quot;</span>);</span><br><span class="line">        jedis.set(<span class="string">&quot;k2&quot;</span>,<span class="string">&quot;v2&quot;</span>);</span><br><span class="line">        jedis.set(<span class="string">&quot;k3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; keys = jedis.keys(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        System.out.println(keys.size());</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.println(key);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;Key API exists &quot;</span> + jedis.exists(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Key API ttl &quot;</span> + jedis.ttl(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;Key API get &quot;</span> +jedis.get(<span class="string">&quot;k1&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//String</span></span><br><span class="line">        jedis.mset(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;v1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;v2&quot;</span>,<span class="string">&quot;str3&quot;</span>,<span class="string">&quot;v3&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;String API &gt;&gt;mset &gt;&gt;&gt; mget &quot;</span> + jedis.mget(<span class="string">&quot;str1&quot;</span>,<span class="string">&quot;str2&quot;</span>,<span class="string">&quot;str3&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//List</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;mylist&quot;</span>,<span class="string">&quot;l1&quot;</span>,<span class="string">&quot;l2&quot;</span>,<span class="string">&quot;l3&quot;</span>);</span><br><span class="line">        List&lt;String&gt; mylist = jedis.lrange(<span class="string">&quot;mylist&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : mylist) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;List API lpush&gt;&gt;lrange: &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//set</span></span><br><span class="line">        jedis.sadd(<span class="string">&quot;orders&quot;</span>,<span class="string">&quot;order01&quot;</span>,<span class="string">&quot;order02&quot;</span>,<span class="string">&quot;order3&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; orders = jedis.smembers(<span class="string">&quot;orders&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String order : orders) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Set API&gt;&gt;sadd&gt;&gt;smembers &quot;</span> + order);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.srem(<span class="string">&quot;orders&quot;</span>,<span class="string">&quot;order02&quot;</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//hash</span></span><br><span class="line">        jedis.hset(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;userName&quot;</span>,<span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;hash API:hset&gt;&gt;hget :&quot;</span> + jedis.hget(<span class="string">&quot;hash&quot;</span>,<span class="string">&quot;userName&quot;</span>));</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;telphone&quot;</span>,<span class="string">&quot;15759029165&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;address&quot;</span>,<span class="string">&quot;longyan&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;email&quot;</span>,<span class="string">&quot;1575018859@qq.com&quot;</span>);</span><br><span class="line">        jedis.hmset(<span class="string">&quot;hash2&quot;</span>,map);</span><br><span class="line">        List&lt;String&gt; result = jedis.hmget(<span class="string">&quot;hash2&quot;</span>, <span class="string">&quot;telphone&quot;</span>, <span class="string">&quot;email&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : result) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;hash &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//zset</span></span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>,<span class="number">100d</span>,<span class="string">&quot;z3&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>,<span class="number">90d</span>,<span class="string">&quot;l4&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>,<span class="number">80d</span>,<span class="string">&quot;w5&quot;</span>);</span><br><span class="line">        jedis.zadd(<span class="string">&quot;zset01&quot;</span>,<span class="number">70d</span>,<span class="string">&quot;z5&quot;</span>);</span><br><span class="line">        Set&lt;String&gt; zset01 = jedis.zrange(<span class="string">&quot;zset01&quot;</span>, <span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (String s : zset01) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;zset&gt;&gt; &quot;</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis-Jedis-实例"><a href="#Redis-Jedis-实例" class="headerlink" title="Redis-Jedis-实例"></a>Redis-Jedis-实例</h2><h3 id="手机验证码"><a href="#手机验证码" class="headerlink" title="手机验证码"></a><strong>手机验证码</strong></h3><p>输入手机号，点击发送后随机生成6位数字码，2分钟有效</p><p>输入验证码，点击验证，返回成功或失败</p><p>每个手机号每天只能输入3次</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneCode</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        verifyCode(<span class="string">&quot;15759029165&quot;</span>);</span><br><span class="line">        <span class="comment">//getRedisCode(&quot;15759029165&quot;,&quot;438209&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1 生成手机验证码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        String code = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> ran = random.nextInt(<span class="number">10</span>);</span><br><span class="line">            code += ran;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 每个手机每天只能发送3次，验证码放到redis中，设置过期时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">verifyCode</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;121.199.76.44&quot;</span>, <span class="number">6379</span>);</span><br><span class="line">        <span class="comment">//拼接Key</span></span><br><span class="line">        <span class="comment">//手机发送次数key</span></span><br><span class="line">        String countKey = <span class="string">&quot;VerifyCode&quot;</span> + phone + <span class="string">&quot;:count&quot;</span>;</span><br><span class="line">        <span class="comment">//验证码key</span></span><br><span class="line">        String codeKey = <span class="string">&quot;VerifyCode&quot;</span> + phone + <span class="string">&quot;:code&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String count = jedis.get(countKey);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//没有发送次数，第一次发送</span></span><br><span class="line">            <span class="comment">//设置发送次数是1</span></span><br><span class="line">            jedis.setex(countKey, <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count) &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">            jedis.incr(countKey);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (Integer.parseInt(count)&gt;<span class="number">2</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;今天发送次数已经超过3次&quot;</span>);</span><br><span class="line">            jedis.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送验证码放到redis里面</span></span><br><span class="line">        String vcode = getCode();</span><br><span class="line">        jedis.setex(codeKey,<span class="number">60</span>,vcode);</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3 验证码校验</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getRedisCode</span><span class="params">(String phone,String code)</span></span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">&quot;121.199.76.44&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        String codeKey = <span class="string">&quot;VerifyCode&quot;</span> + phone + <span class="string">&quot;:code&quot;</span>;</span><br><span class="line">        String redisCode = jedis.get(codeKey);</span><br><span class="line">        <span class="keyword">if</span> (redisCode.equals(code))&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Redis与SpringBoot整合"><a href="#Redis与SpringBoot整合" class="headerlink" title="Redis与SpringBoot整合"></a><strong>Redis与SpringBoot整合</strong></h2><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.luxiaobai<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>spring-redis<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- redis --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- spring2.X集成redis所需common-pool2--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="appplication-properties"><a href="#appplication-properties" class="headerlink" title="appplication.properties"></a><strong>appplication.properties</strong></h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Redis服务器地址</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">192.168.0.101</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">#Redis数据库索引（默认为0）</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">0</span></span><br><span class="line"><span class="comment">#连接超时时间（毫秒）</span></span><br><span class="line"><span class="meta">spring.redis.timeout</span>=<span class="string">1800000</span></span><br><span class="line"><span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-active</span>=<span class="string">20</span></span><br><span class="line"><span class="comment">#最大阻塞等待时间（负数表示没有限制）</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.max-wait</span>=<span class="string">-1</span></span><br><span class="line"><span class="comment">#连接池中的最大空闲连接</span></span><br><span class="line"><span class="meta">spring.redis.lettuce.pool.min-idle</span>=<span class="string">0</span></span><br></pre></td></tr></table></figure><h3 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a><strong>配置类</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;&gt;();</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        template.setConnectionFactory(factory);</span><br><span class="line">        <span class="comment">//key序列化方式</span></span><br><span class="line">        template.setKeySerializer(redisSerializer);</span><br><span class="line">        <span class="comment">//value序列化</span></span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="comment">//value hashmap序列化</span></span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory factory)</span> </span>&#123;</span><br><span class="line">        RedisSerializer&lt;String&gt; redisSerializer = <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer(Object.class);</span><br><span class="line">        <span class="comment">//解决查询缓存转换异常的问题</span></span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line">        <span class="comment">// 配置序列化（解决乱码的问题）,过期时间600秒</span></span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                .entryTtl(Duration.ofSeconds(<span class="number">600</span>))</span><br><span class="line">                .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(redisSerializer))</span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jackson2JsonRedisSerializer))</span><br><span class="line">                .disableCachingNullValues();</span><br><span class="line">        RedisCacheManager cacheManager = RedisCacheManager.builder(factory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> cacheManager;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/redisTest&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTestController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testRedist</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//设置值到redis</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">        <span class="comment">//从redis取值</span></span><br><span class="line">        String name = (String) redisTemplate.opsForValue().get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redis事务—-锁机制-秒杀"><a href="#Redis事务—-锁机制-秒杀" class="headerlink" title="Redis事务—-锁机制-秒杀"></a>Redis事务—-锁机制-秒杀</h1><h2 id="Redis的事务定义"><a href="#Redis的事务定义" class="headerlink" title="Redis的事务定义"></a><strong>Redis的事务定义</strong></h2><p>Redis事务是一个单独的隔离操作：<strong>事务中的所有命令都会序列化、按顺序地执行</strong>。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p><p>Redis事务的主要<strong>作用</strong>就是<strong>串联多个命令防止别的命令插队。</strong></p><h2 id="Multi、Exec、discard"><a href="#Multi、Exec、discard" class="headerlink" title="Multi、Exec、discard"></a><strong>Multi、Exec、discard</strong></h2><p>从输入Multi命令开始，输入的命令都会依次进入命令队列中，但不会执行，直到输入Exec后，Redis会将之前的命令队列中的命令依次执行。</p><p>组队的过程中可以通过discard来放弃组队。  </p><p><img src="http://qiliu.luxiaobai.cn/img/redistran.png" alt="redistran"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set k3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) OK</span><br><span class="line">组队成功,提交成功</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; set m1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set m2</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;set&#x27; command</span><br><span class="line">127.0.0.1:6379(TX)&gt; set m3 v3</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">(error) EXECABORT Transaction discarded because of previous errors.</span><br><span class="line">组队阶段报错,提交失败</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; multi</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379(TX)&gt; set m1 v1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; incr m1</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; set m2 v2</span><br><span class="line">QUEUED</span><br><span class="line">127.0.0.1:6379(TX)&gt; exec</span><br><span class="line">1) OK</span><br><span class="line">2) (error) ERR value is not an integer or out of range</span><br><span class="line">3) OK</span><br><span class="line">组队成功,提交有成功有失败情况</span><br></pre></td></tr></table></figure><h2 id="事务的错误处理"><a href="#事务的错误处理" class="headerlink" title="事务的错误处理"></a><strong>事务的错误处理</strong></h2><p>组队中某个命令出现了报告错误，执行时整个的所有队列都会被取消。</p><p><img src="/Users/lushengyang/Desktop/LSY/StudeyNotes/redis/Redis3.assets/redistran1.png" alt="redistran1"></p><p>如果执行阶段某个命令报出了错误，则只有报错的命令不会被执行，而其他的命令都会执行，不会回滚。</p><p><img src="http://qiliu.luxiaobai.cn/img/redistran2.png" alt="redistran2"></p><h2 id="事务冲突问题"><a href="#事务冲突问题" class="headerlink" title="事务冲突问题"></a><strong>事务冲突问题</strong></h2><p><strong>实例</strong></p><p>一个请求想给金额减8000</p><p>一个请求想给金额减5000</p><p>一个请求想给金额减1000</p><p><img src="http://qiliu.luxiaobai.cn/img/redistan3.png" alt="redistan3"></p><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p><img src="http://qiliu.luxiaobai.cn/img/redistran4.png" alt="redistran4"></p><blockquote><p><strong>悲观锁(Pessimistic Lock)</strong>, 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p></blockquote><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><blockquote><p>乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用<strong>版本号等机制</strong>。乐观锁适用于多读的应用类型，这样可以提高吞吐量。Redis就是利用这种check-and-set机制实现事务的。</p></blockquote><p><img src="http://qiliu.luxiaobai.cn/img/%E4%B9%90%E8%A7%82%E9%94%81.png" alt="乐观锁"></p><h3 id="WATCH-key-key…"><a href="#WATCH-key-key…" class="headerlink" title="WATCH key[key…]"></a>WATCH key[key…]</h3><p>在执行multi之前，先执行watch key1 [key2],可以监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; multi</span><br><span class="line">OK</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>(TX)&gt; decrby balance <span class="number">10</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>(TX)&gt; incrby debt <span class="number">10</span></span><br><span class="line">QUEUED</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>(TX)&gt; exec</span><br><span class="line"><span class="number">1</span>) (integer) -<span class="number">10</span></span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">10</span></span><br></pre></td></tr></table></figure><h3 id="unwatch"><a href="#unwatch" class="headerlink" title="unwatch"></a><strong>unwatch</strong></h3><p>取消 WATCH 命令对所有 key 的监视。</p><p>如果在执行 WATCH 命令之后，EXEC 命令或DISCARD 命令先被执行了的话，那么就不需要再执行UNWATCH 了。</p><h2 id="Redis事务三特性"><a href="#Redis事务三特性" class="headerlink" title="Redis事务三特性"></a><strong>Redis事务三特性</strong></h2><ul><li><p><strong>单独的隔离操作</strong></p></li><li><ul><li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li></ul></li><li><p><strong>没有隔离级别的概念</strong></p></li><li><ul><li>n 队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li></ul></li><li><p><strong>不保证原子性</strong></p></li><li><ul><li>n 事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚</li></ul></li></ul><h2 id="Redis-事务-秒杀案例"><a href="#Redis-事务-秒杀案例" class="headerlink" title="Redis-事务-秒杀案例"></a><strong>Redis-事务-秒杀案例</strong></h2><h3 id="解决计数器和人员记录的事务操作"><a href="#解决计数器和人员记录的事务操作" class="headerlink" title="解决计数器和人员记录的事务操作"></a><strong>解决计数器和人员记录的事务操作</strong></h3><p><img src="http://qiliu.luxiaobai.cn/img/redistran5.png" alt="redistran5"></p><h3 id="Redis事务–秒杀并发模拟"><a href="#Redis事务–秒杀并发模拟" class="headerlink" title="Redis事务–秒杀并发模拟"></a><strong>Redis事务–秒杀并发模拟</strong></h3><h4 id="工具ab模拟测试"><a href="#工具ab模拟测试" class="headerlink" title="工具ab模拟测试"></a><strong>工具ab模拟测试</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ubuntu</span></span><br><span class="line">sudo apt-get install apache2-utils </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">CentOS</span></span><br><span class="line">sudo yum -y install httpd-tools</span><br><span class="line"><span class="meta">#</span><span class="bash">联网</span></span><br><span class="line">yum install httpd-tools</span><br></pre></td></tr></table></figure><p><strong>vim postfile 模拟表单提交参数,以&amp;符号结尾;存放当前目录。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prodid=0101&amp;</span><br><span class="line">ab -n 2000 -c 200 -k -p ~/postfile -T application/x-www-form-urlencoded http://127.0.0.1:8081/Seckill/doseckill</span><br></pre></td></tr></table></figure><h2 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a><strong>超卖问题</strong></h2><img src="http://qiliu.luxiaobai.cn/img/redischao1.png" alt="redischao1" style="zoom: 67%;" /><p><strong>利用乐观锁淘汰用户，解决超卖问题</strong></p><img src="http://qiliu.luxiaobai.cn/img/rediscaho2.png" alt="rediscaho2" style="zoom:67%;" /><p><strong>连接超时，通过连接池解决</strong></p><p>节省每次连接redis服务带来的消耗，把连接好的实例反复利用。通过参数管理连接的行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//连接池工具类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtil</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> JedisPool jedisPool = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JedisPoolUtil</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JedisPool <span class="title">getJedisPoolInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (JedisPoolUtil.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == jedisPool) &#123;</span><br><span class="line">                    JedisPoolConfig poolConfig = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">                    poolConfig.setMaxTotal(<span class="number">200</span>);</span><br><span class="line">                    poolConfig.setMaxTotal(<span class="number">32</span>);</span><br><span class="line">                    poolConfig.setMaxWaitMillis(<span class="number">100</span> * <span class="number">1000</span>);</span><br><span class="line">                    poolConfig.setTestOnBorrow(<span class="keyword">true</span>);<span class="comment">//ping PONG</span></span><br><span class="line"></span><br><span class="line">                    jedisPool = <span class="keyword">new</span> JedisPool(poolConfig, <span class="string">&quot;121.199.76.44&quot;</span>, <span class="number">6379</span>, <span class="number">6000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> jedisPool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(JedisPool jedisPool, Jedis jedis)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != jedis) &#123;</span><br><span class="line">            jedisPool.returnResource(jedis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>连接池参数</strong></p><ul><li>MaxTotal：控制一个pool可分配多少个jedis实例，通过pool.getResource()来获取；如果赋值为-1，则表示不限制；如果pool已经分配了MaxTotal个jedis实例，则此时pool的状态为exhausted。</li><li>maxIdle：控制一个pool最多有多少个状态为idle(空闲)的jedis实例；</li><li>MaxWaitMillis：表示当borrow一个jedis实例时，最大的等待毫秒数，如果超过等待时间，则直接抛JedisConnectionException；</li><li>testOnBorrow：获得一个jedis实例的时候是否检查连接可用性（ping()）；如果为true，则得到的jedis实例均是可用的；</li></ul><h2 id="库存遗留问题"><a href="#库存遗留问题" class="headerlink" title="库存遗留问题"></a><strong>库存遗留问题</strong></h2><p><img src="http://qiliu.luxiaobai.cn/img/redisyiliu.png" alt="redisyiliu"></p><h1 id="LUA脚本"><a href="#LUA脚本" class="headerlink" title="LUA脚本"></a>LUA脚本</h1><p><img src="http://qiliu.luxiaobai.cn/img/LUA.png" alt="LUA"></p><blockquote><p>Lua 是一个小巧的<a href="http://baike.baidu.com/item/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80">脚本语言</a>，Lua脚本可以很容易的被C/C++ 代码调用，也可以反过来调用C/C++的函数，Lua并没有提供强大的库，一个完整的Lua解释器不过200k，所以Lua不适合作为开发独立应用程序的语言，而是作为嵌入式脚本语言。很多应用程序、游戏使用LUA作为自己的嵌入式脚本语言，以此来实现可配置性、可扩展性。</p><p>这其中包括魔兽争霸地图、魔兽世界、博德之门、愤怒的小鸟等众多游戏插件或外挂。</p><p><a href="https://www.w3cschool.cn/lua/">https://www.w3cschool.cn/lua/</a></p></blockquote><p><strong>ubuntu 安装</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下载编译包</span></span><br><span class="line">curl -R -O http://www.lua.org/ftp/lua-5.3.0.tar.gz</span><br><span class="line">tar zxf lua-5.3.0.tar.gz</span><br><span class="line">cd lua-5.3.0</span><br><span class="line">make linux</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><img src="http://qiliu.luxiaobai.cn/img/lua1.png" alt="lua1"></p><p>错误原因就是缺少依赖包libreadline-dev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos: yum install readline-devel</span><br><span class="line">Ubuntu: sudo apt-get install libreadline-dev.</span><br></pre></td></tr></table></figure><h2 id="LUA脚本在Redis中的优势"><a href="#LUA脚本在Redis中的优势" class="headerlink" title="LUA脚本在Redis中的优势"></a><strong>LUA脚本在Redis中的优势</strong></h2><p>将复杂的或者多步的redis操作，写为一个脚本，一次提交给redis执行，减少反复连接redis的次数。提升性能。LUA脚本是类似redis事务，有一定的原子性，不会被其他命令插队，可以完成一些redis事务性的操作。但是注意redis的lua脚本功能，只有在Redis 2.6以上的版本才可以使用。利用lua脚本淘汰用户，解决超卖问题。</p><p>redis 2.6版本以后，通过lua脚本解决争抢问题，实际上是redis 利用其单线程的特性，用任务队列的方式解决多任务并发问题</p><p><img src="http://qiliu.luxiaobai.cn/img/lua2.png" alt="lua2"></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> userid=KEYS[<span class="number">1</span>]; </span><br><span class="line"><span class="keyword">local</span> prodid=KEYS[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">local</span> qtkey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:qt&quot;</span>;</span><br><span class="line"><span class="keyword">local</span> usersKey=<span class="string">&quot;sk:&quot;</span>..prodid..<span class="string">&quot;:usr&#x27;; </span></span><br><span class="line"><span class="string">local userExists=redis.call(&quot;</span>sismember<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">if tonumber(userExists)==1 then </span></span><br><span class="line"><span class="string">  return 2;</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">local num= redis.call(&quot;</span>get<span class="string">&quot; ,qtkey);</span></span><br><span class="line"><span class="string">if tonumber(num)&lt;=0 then </span></span><br><span class="line"><span class="string">  return 0; </span></span><br><span class="line"><span class="string">else </span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>decr<span class="string">&quot;,qtkey);</span></span><br><span class="line"><span class="string">  redis.call(&quot;</span>sadd<span class="string">&quot;,usersKey,userid);</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">return 1;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecKill_redisByScript</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(SecKill_redisByScript.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        System.out.println(jedis.ping());</span><br><span class="line">        Set&lt;HostAndPort&gt; set = <span class="keyword">new</span> HashSet&lt;HostAndPort&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//doSecKill(&quot;201&quot;,&quot;sk:0101&quot;);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String secKillScript = <span class="string">&quot;local userid=KEYS[1];\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local prodid=KEYS[2];\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local qtkey=&#x27;sk:&#x27;..prodid..\&quot;:qt\&quot;;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local usersKey=&#x27;sk:&#x27;..prodid..\&quot;:usr\&quot;;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local userExists=redis.call(\&quot;sismember\&quot;,usersKey,userid);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if tonumber(userExists)==1 then \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 2;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;local num= redis.call(\&quot;get\&quot; ,qtkey);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;if tonumber(num)&lt;=0 then \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   return 0;\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;else \r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(\&quot;decr\&quot;,qtkey);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;   redis.call(\&quot;sadd\&quot;,usersKey,userid);\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;end\r\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;return 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String secKillScript2 =</span><br><span class="line">            <span class="string">&quot;local userExists=redis.call(\&quot;sismember\&quot;,\&quot;&#123;sk&#125;:0101:usr\&quot;,userid);\r\n&quot;</span> +</span><br><span class="line">                    <span class="string">&quot; return 1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doSecKill</span><span class="params">(String uid, String prodid)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance();</span><br><span class="line">        Jedis jedis = jedisPool.getResource();</span><br><span class="line">        String sha1 = jedis.scriptLoad(secKillScript);</span><br><span class="line">        Object result = jedis.evalsha(sha1, <span class="number">2</span>, uid, prodid);</span><br><span class="line">        String reString = String.valueOf(result);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;0&quot;</span>.equals(reString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;已抢空！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(reString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抢购成功！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;2&quot;</span>.equals(reString)) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;该用户已抢过！！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;抢购异常！！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        jedis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;Redis-Jedis-测试&quot;&gt;&lt;a href=&quot;#Redis-Jedis-测试&quot; class=&quot;headerlink&quot; title=&quot;Redis_Jedis_测试&quot;&gt;&lt;/a&gt;&lt;strong&gt;Redis_Jedis_测试&lt;/strong&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis6入门学习(二)</title>
    <link href="https://luxiaobai.cn/2021/10/08/redis/Redis2/"/>
    <id>https://luxiaobai.cn/2021/10/08/redis/Redis2/</id>
    <published>2021-10-08T03:01:30.257Z</published>
    <updated>2021-10-11T01:54:16.403Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="Redis6配置文件"><a href="#Redis6配置文件" class="headerlink" title="Redis6配置文件"></a>Redis6配置文件</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//配置文件路径</span><br><span class="line">vim /etc/redis/redis.conf</span><br></pre></td></tr></table></figure><h2 id="Units单位"><a href="#Units单位" class="headerlink" title="Units单位"></a><strong>Units单位</strong></h2><p>配置大小单位,开头定义了一些基本的度量单位，只支持bytes，不支持bit大小写不敏感</p><p><img src="http://qiliu.luxiaobai.cn/img/redisconf1.png" alt="redisconf1"></p><h2 id="INCLUDES包含"><a href="#INCLUDES包含" class="headerlink" title="INCLUDES包含"></a><strong>INCLUDES包含</strong></h2><p><img src="http://qiliu.luxiaobai.cn/img/redis6.png" alt="redis6"></p><p>类似jsp中的include，多实例的情况可以把公用的配置文件提取出来</p><h2 id="网络相关配置"><a href="#网络相关配置" class="headerlink" title="网络相关配置"></a>网络相关配置</h2><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>默认情况bind=127.0.0.1只能接受本机的访问请求,不写的情况下，无限制接受任何ip地址的访问</p><p>生产环境肯定要写你应用服务器的地址；服务器是需要远程访问的，所以需要将其注释掉</p><p>如果开启了protected-mode，那么在没有设定bind ip且没有设密码的情况下，Redis只允许接受本机的响应</p><p><img src="http://qiliu.luxiaobai.cn/img/rediscof.png" alt="rediscof"></p><p>保存配置,重启服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli</span><br><span class="line">shutdown</span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><h3 id="protected-mode"><a href="#protected-mode" class="headerlink" title="protected-mode"></a><strong>protected-mode</strong></h3><p>protected-mode配置，默认是yes，即开启。设置外部网络连接redis服务，设置方式如下：</p><p>1、关闭protected-mode模式，此时外部网络可以直接访问</p><p>2、开启protected-mode保护模式，需配置bind ip或者设置访问密码</p><h3 id="tcp-backlog"><a href="#tcp-backlog" class="headerlink" title="tcp-backlog"></a><strong>tcp-backlog</strong></h3><p>设置tcp的backlog，backlog其实是一个连接队列，backlog队列总和=未完成三次握手队列 + 已经完成三次握手队列。</p><p>在高并发环境下你需要一个高backlog值来避免慢客户端连接问题。</p><p>注意Linux内核会将这个值减小到/proc/sys/net/core/somaxconn的值（128），所以需要确认增大/proc/sys/net/core/somaxconn和/proc/sys/net/ipv4/tcp_max_syn_backlog（128）两个值来达到想要的效果</p><p><img src="http://qiliu.luxiaobai.cn/img/redisconf2.png" alt="redisconf2"></p><h3 id="timeout"><a href="#timeout" class="headerlink" title="timeout"></a><strong>timeout</strong></h3><p>一个空闲的客户端维持多少秒会关闭，0表示关闭该功能。即永不关闭。</p><h3 id="tcp-keepalive"><a href="#tcp-keepalive" class="headerlink" title="tcp-keepalive"></a><strong>tcp-keepalive</strong></h3><p>对访问客户端的一种心跳检测，每个n秒检测一次。单位为秒，如果设置为0，则不会进行Keepalive检测，建议设置成60</p><p><img src="http://qiliu.luxiaobai.cn/img/redisconf3.png" alt="redisconf3"></p><h2 id="GENERAL通用"><a href="#GENERAL通用" class="headerlink" title="GENERAL通用"></a><strong>GENERAL通用</strong></h2><h3 id="daemonize"><a href="#daemonize" class="headerlink" title="daemonize"></a><strong>daemonize</strong></h3><p>是否为后台进程，设置为yes 守护进程，后台启动</p><h3 id="pidfile"><a href="#pidfile" class="headerlink" title="pidfile"></a><strong>pidfile</strong></h3><p>存放pid文件的位置，每个实例会产生一个不同的pid文件</p><h3 id="loglevel"><a href="#loglevel" class="headerlink" title="loglevel"></a><strong>loglevel</strong></h3><p>指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为notice</p><p>四个级别根据使用阶段来选择，<strong>生产环境选择notice 或者warning</strong></p><h3 id="logfile"><a href="#logfile" class="headerlink" title="logfile"></a><strong>logfile</strong></h3><h3 id="databases16"><a href="#databases16" class="headerlink" title="databases16"></a><strong>databases16</strong></h3><p>设定库的数量 默认16，默认数据库为0，可以使用SELECT <dbid>命令在连接上指定数据库id</p><h2 id="SECURITY安全"><a href="#SECURITY安全" class="headerlink" title="SECURITY安全"></a><strong>SECURITY安全</strong></h2><p><strong>设置密码</strong></p><p><img src="http://qiliu.luxiaobai.cn/img/redisconf4.png" alt="redisconf4"></p><p>访问密码的查看、设置和取消</p><p>在命令中设置密码，只是临时的。重启redis服务器，密码就还原了。</p><p>永久设置，需要再配置文件中进行设置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">root@iZbp13941xpzjmefjge9chZ:/etc# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">1) &quot;requirepass&quot;</span><br><span class="line">2) &quot;&quot;</span><br><span class="line">127.0.0.1:6379&gt; config set requirepass &quot;123456&quot;</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; config get requirepass</span><br><span class="line">(error) NOAUTH Authentication required.</span><br><span class="line">127.0.0.1:6379&gt; auth 123456</span><br><span class="line">OK</span><br></pre></td></tr></table></figure><h2 id="LIMITS限制"><a href="#LIMITS限制" class="headerlink" title="LIMITS限制"></a><strong>LIMITS限制</strong></h2><h3 id="maxclients"><a href="#maxclients" class="headerlink" title="maxclients"></a><strong>maxclients</strong></h3><p>设置redis同时可以与多少个客户端进行连接。</p><p>默认情况下为10000个客户端。</p><p>如果达到了此限制，redis则会拒绝新的连接请求，并且向这些连接请求方发出“max number of clients reached”以作回应。</p><p><img src="http://qiliu.luxiaobai.cn/img/redisconf5.png" alt="redisconf5"></p><h3 id="maxmemory"><a href="#maxmemory" class="headerlink" title="maxmemory"></a><strong>maxmemory</strong></h3><ul><li>建议必须设置，否则，将内存占满，造成服务器宕机</li><li>设置redis可以使用的内存量。一旦到达内存使用上限，redis将会试图移除内部数据，移除规则可以通过<strong>maxmemory-policy</strong>来指定。</li><li>如果redis无法根据移除规则来移除内存中的数据，或者设置了“不允许移除”，那么redis则会针对那些需要申请内存的指令返回错误信息，比如SET、LPUSH等。</li><li>但是对于无内存申请的指令，仍然会正常响应，比如GET等。如果你的redis是主redis（说明你的redis有从redis），那么在设置内存使用上限时，需要在系统中留出一些内存空间给同步队列缓存，只有在你设置的是“不移除”的情况下，才不用考虑这个因素。</li></ul><p><img src="http://qiliu.luxiaobai.cn/img/redisconf6.png" alt="redisconf6"></p><h3 id="maxmemory-policy"><a href="#maxmemory-policy" class="headerlink" title="maxmemory-policy"></a><strong>maxmemory-policy</strong></h3><p><strong>volatile-lru</strong>：使用LRU算法移除key，只对设置了过期时间的键；（最近最少使用）</p><p><strong>allkeys-lru</strong>：在所有集合key中，使用LRU算法移除key</p><p><strong>volatile-random</strong>：在过期集合中移除随机的key，只对设置了过期时间的键</p><p><strong>allkeys-random</strong>：在所有集合key中，移除随机的key</p><p><strong>volatile-ttl</strong>：移除那些TTL值最小的key，即那些最近要过期的key</p><p><strong>noeviction</strong>：不进行移除。针对写操作，只是返回错误信息</p><p><img src="http://qiliu.luxiaobai.cn/img/redisconf7.png" alt="redisconf7"></p><h3 id="maxmemory-samples"><a href="#maxmemory-samples" class="headerlink" title="maxmemory-samples"></a><strong>maxmemory-samples</strong></h3><ul><li>设置样本数量，LRU算法和最小TTL算法都并非是精确的算法，而是估算值，所以你可以设置样本的大小，redis默认会检查这么多个key并选择其中LRU的那个。</li><li>一般设置3到7的数字，数值越小样本越不准确，但性能消耗越小。</li></ul><p><img src="http://qiliu.luxiaobai.cn/img/redisconf8.png" alt="redisconf8"></p><h1 id="Redis6的发布和订阅"><a href="#Redis6的发布和订阅" class="headerlink" title="Redis6的发布和订阅"></a>Redis6的发布和订阅</h1><blockquote><p>Redis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息。</p><p>Redis 客户端可以订阅任意数量的频道。</p></blockquote><h2 id="Redis的发布和订阅"><a href="#Redis的发布和订阅" class="headerlink" title="Redis的发布和订阅"></a><strong>Redis的发布和订阅</strong></h2><p><strong>1、客户端可以订阅频道</strong></p><p><img src="http://qiliu.luxiaobai.cn/img/redispub1.png" alt="redispub1"></p><p><strong>2、当给这个频道发布消息后，消息就会发送给订阅的客户端</strong></p><p><img src="http://qiliu.luxiaobai.cn/img/redispub2.png" alt="redispub2"></p><h2 id="发布订阅命令行实现"><a href="#发布订阅命令行实现" class="headerlink" title="发布订阅命令行实现"></a><strong>发布订阅命令行实现</strong></h2><p>1、 打开一个客户端订阅channel1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE channel1</span><br></pre></td></tr></table></figure><p>2、打开另一个客户端，给channel1发布消息hello</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; publish channel hello (integer) 1</span><br></pre></td></tr></table></figure><p>返回的1是订阅者数量</p><p>3、打开第一个客户端可以看到发送的消息</p><p><img src="http://qiliu.luxiaobai.cn/img/redispub4.png" alt="redispub4"></p><blockquote><p>发布的消息没有持久化，如果在订阅的客户端收不到hello，只能收到订阅后发布的消息</p></blockquote><h1 id="Redis6新数据类型"><a href="#Redis6新数据类型" class="headerlink" title="Redis6新数据类型"></a><strong>Redis6新数据类型</strong></h1><h2 id="Bitmaps"><a href="#Bitmaps" class="headerlink" title="Bitmaps"></a><strong>Bitmaps</strong></h2><blockquote><p>现代计算机用二进制（位） 作为信息的基础单位， 1个字节等于8位， 例如“abc”字符串是由3个字节组成， 但实际在计算机存储时将其用二进制表示， “abc”分别对应的ASCII码分别是97、 98、 99， 对应的二进制分别是01100001、 01100010和01100011</p></blockquote><p><img src="http://qiliu.luxiaobai.cn/img/redisdata1.png" alt="redisdata1"></p><p>合理地使用操作位能够有效地提高内存使用率和开发效率。</p><p>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</p><p>（1） Bitmaps本身不是一种数据类型， 实际上它就是字符串（key-value） ， 但是它可以对字符串的位进行操作。</p><p>（2） Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把Bitmaps想象成一个以位为单位的数组， 数组的每个单元只能存储0和1， 数组的下标在Bitmaps中叫做偏移量。</p><p><img src="http://qiliu.luxiaobai.cn/img/redisdata2.png" alt="redisdata2"></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a><strong>命令</strong></h3><p><strong>setbit</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setbit &lt;key&gt;&lt;offset&gt;&lt;value&gt;                 设置Bitmaps中某个偏移量的值（0或1）</span><br></pre></td></tr></table></figure><p>offset:偏移量从0开始</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>每个独立用户是否访问过网站存放在Bitmaps中， 将访问的用户记做1， 没有访问的用户记做0， 用偏移量作为用户的id。</p><p>设置键的第offset个位的值（从0算起） ， 假设现在有20个用户，userid=1， 6， 11， 15， 19的用户对网站进行了访问， 那么当前Bitmaps初始化结果如图</p><p><img src="http://qiliu.luxiaobai.cn/img/redisdata3.png" alt="redisdata3"></p><p>unique:users:20201106代表2020-11-06这天的独立访问用户的Bitmaps</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201106 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201106 6 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201106 11 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201106 15 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201106 19 1</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><blockquote><p>很多应用的用户id以一个指定数字（例如10000） 开头， 直接将用户id和Bitmaps的偏移量对应势必会造成一定的浪费， 通常的做法是每次做setbit操作时将用户id减去这个指定数字。</p><p>在第一次初始化Bitmaps时， 假如偏移量非常大， 那么整个初始化过程执行会比较慢， 可能会造成Redis的阻塞。</p></blockquote><h2 id="getbit"><a href="#getbit" class="headerlink" title="getbit"></a>getbit</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getbit &lt;key&gt; &lt;offset&gt;        获取Bitmaps中某个偏移量的值</span><br></pre></td></tr></table></figure><p>获取键的第offset位的值(从0开始算</p><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h3><p>获取 id=8的用户是否在2020-11-06这天访问过， 返回0说明没有访问过：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getbit unique:users:20201106 8</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit unique:users:20201106 1</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit unique:users:20201106 100</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure><p>==因为100根本不存在,所以返回0==</p><h2 id="bitcount"><a href="#bitcount" class="headerlink" title="bitcount"></a><strong>bitcount</strong></h2><p>统计字符串被设置为1的bit数。一般情况下，给定的整个字符串都会被进行计数，通过指定额外的 start 或 end 参数，可以让计数只在特定的位上进行。start 和 end 参数的设置，都可以使用负数值：比如 -1 表示最后一个位，而 -2 表示倒数第二个位，start、end 是指bit组的字节的下标数，二者皆包含。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitcount&lt;key&gt;[start end]  统计字符串从start字节到end字节比特值为1的数量</span><br></pre></td></tr></table></figure><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>2022-11-06这天的独立访问用户数量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount unique:users:20201106</span><br><span class="line">(integer) 5</span><br></pre></td></tr></table></figure><p>start和end代表起始和结束字节数， 下面操作计算用户id在第1个字节到第3个字节之间的独立访问用户数， 对应的用户id是11， 15， 19。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; bitcount unique:users:20201106 1 3</span><br><span class="line">(integer) 3</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#1个字节8位</span></span></span><br></pre></td></tr></table></figure><blockquote><p><strong>redis的setbit设置或清除的是bit位置，而bitcount计算的是byte位置。</strong></p></blockquote><h2 id="bitop"><a href="#bitop" class="headerlink" title="bitop"></a><strong>bitop</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bitop and(or/not/xor) &lt;destkey&gt; [key...]</span><br></pre></td></tr></table></figure><p>bitop是一个复合操作， 它可以做多个Bitmaps的and（交集） 、 or（并集） 、 not（非） 、 xor（异或） 操作并将结果保存在destkey中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201104 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201104 2 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201104 5 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201104 9 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201103 0 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201103 1 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201103 4 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit unique:users:20201103 9 1</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; bitop and unique:users:and:20201104_03 unique:users:20201103 unique:users:20201104</span><br><span class="line">(integer) 2</span><br></pre></td></tr></table></figure><h2 id="Bitmaps与set对比"><a href="#Bitmaps与set对比" class="headerlink" title="Bitmaps与set对比"></a><strong>Bitmaps与set对比</strong></h2><p>假设网站有1亿用户， 每天独立访问的用户有5千万， 如果每天用集合类型和Bitmaps分别存储活跃用户可以得到表</p><table>    <tr align="center">        <th colspan="9">set和Bitmaps存储独立用户空间对比</th>    </tr >    <tr align="center">        <td>数据类型</td>        <td>一天</td>        <td>一个月</td>    <td>一年</td>    </tr>    <tr align="center">        <td>集合类型</td>        <td>400MB</td>        <td>12GB</td>        <td>144GB</td>    </tr>    <tr align="center">        <td>Bitmaps</td>        <td>12.5MB</td>        <td>375MB</td>        <td>4.5GB</td>    </tr></table><p>很明显， 这种情况下使用Bitmaps能节省很多的内存空间， 尤其是随着时间推移节省的内存还是非常可观的</p><p>但Bitmaps并不是万金油， 假如该网站每天的独立访问用户很少， 例如只有10万（大量的僵尸用户） ， 那么两者的对比如下表所示， 很显然， 这时候使用Bitmaps就不太合适了， 因为基本上大部分位都是0</p><table>    <tr>        <th align="center" colspan="9">set和Bitmaps存储一天活跃用户对比（独立用户比较少)</th>    </tr >    <tr align="center">        <td>数据类型</td>        <td>每个userid占用空间</td>        <td>需要存储的用户量</td>        <td>全部内存量</td>    </tr>    <tr align="center">        <td>集合类型</td>        <td>64位</td>        <td>100000</td>        <td>64位*100000 = 800KB</td>    </tr>    <tr align="center">        <td>Bitmaps</td>        <td>1位</td>        <td>100000000</td>        <td>1位*100000000 = 12.5MB</td>    </tr></table><h2 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a><strong>HyperLogLog</strong></h2><blockquote><p>在工作当中，我们经常会遇到与统计相关的功能需求，比如统计网站PV（PageView页面访问量）,可以使用Redis的incr、incrby轻松实现。但像UV（UniqueVisitor，独立访客）、独立IP数、搜索记录数等需要去重和计数的问题如何解决？这种求集合中不重复元素个数的问题称为基数问题。解决基数问题有很多种方案：</p><p>（1）数据存储在MySQL表中，使用distinct count计算不重复个数</p><p>（2）使用Redis提供的hash、set、bitmaps等数据结构来处理</p><p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于非常大的数据集是不切实际的。能否能够降低一定的精度来平衡存储空间？</p><p>Redis推出了HyperLogLog. Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。什么是基数?比如数据集 {1, 3, 5, 7, 5, 7, 8}， 那么这个数据集的基数集为 {1, 3, 5 ,7, 8}, 基数(不重复元素)为5。 基数估计就是在误差可接受的范围内，快速计算基数。</p></blockquote><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><h4 id="pfadd"><a href="#pfadd" class="headerlink" title="pfadd"></a>pfadd</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pfadd &lt;key&gt;&lt;element&gt;[element...]添加指定元素到HyperLogLog中</span><br></pre></td></tr></table></figure><p>将所有元素添加到指定HyperLogLog数据结构中。如果执行命令后HLL估计的近似基数发生变化，则返回1，否则返回0。</p><h4 id="pfcount"><a href="#pfcount" class="headerlink" title="pfcount"></a>pfcount</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pfcount &lt;key&gt;[key...]  计算HLL的近似基数，可以计算多个HLL</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; pfadd hll1 &quot;redis&quot; &quot;mysql&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd hll1 &quot;redis&quot;</span><br><span class="line">(integer) 0</span><br><span class="line">127.0.0.1:6379&gt; pfcount hll1</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; pfadd hll1 &quot;mongodb&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd h2 &quot;redis&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd h2 &quot;java&quot;</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount hll1 h2</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h4 id="pfmerge"><a href="#pfmerge" class="headerlink" title="pfmerge"></a>pfmerge</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pfmerge &lt;destkey&gt;&lt;sourcekey&gt;[sourcekey...] .  将一个或多个HLL合并后的结果存储在另一个HLL中 比如每月活跃用户可以使用每天的活跃用户来合并计算可得</span><br><span class="line">127.0.0.1:6379&gt; pfcount hll1 h2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; pfmerge h3 hll1 h2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount h3</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure><h2 id="Geospatial"><a href="#Geospatial" class="headerlink" title="Geospatial"></a><strong>Geospatial</strong></h2><blockquote><p>GEO，Geographic，地理信息的缩写。该类型，就是元素的2维坐标，在地图上就是经纬度。redis基于该类型，提供了经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作。</p></blockquote><h3 id="命令-2"><a href="#命令-2" class="headerlink" title="命令"></a>命令</h3><p><strong>geoadd</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geoadd &lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;&lt;member&gt; [longitude latitude member...]   添加地理位置（经度，纬度，名称）</span><br></pre></td></tr></table></figure><p>两极无法直接添加，一般会下载城市数据，直接通过 Java 程序一次性导入。有效的经度从 -180 度到 180 度。有效的纬度从 -85.05112878 度到 85.05112878 度。当坐标位置超出指定范围时，该命令将会返回一个错误。已经添加的数据，是无法再次往里面添加的。</p><h4 id="geopos"><a href="#geopos" class="headerlink" title="geopos"></a><strong>geopos</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">geodist&lt;key&gt;&lt;member1&gt;&lt;member2&gt;  [m|km|ft|mi ]  获取两个位置之间的直线距离</span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing shanghai km</span><br><span class="line">&quot;1068.1535&quot;</span><br></pre></td></tr></table></figure><blockquote><p>单位：</p><p>m 表示单位为米[默认值]。</p><p>km 表示单位为千米。</p><p>mi 表示单位为英里。</p><p>ft 表示单位为英尺。</p><p>如果用户没有显式地指定单位参数， 那么 GEODIST 默认使用米作为单位</p></blockquote><h4 id="georadius"><a href="#georadius" class="headerlink" title="georadius"></a><strong>georadius</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">georadius&lt;key&gt;&lt; longitude&gt;&lt;latitude&gt;radius  m|km|ft|mi   以给定的经纬度为中心，找出某一半径内的元素</span><br><span class="line">经度 纬度 距离 单位</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km</span><br><span class="line">1) &quot;chonggin&quot;</span><br><span class="line">2) &quot;shenzhen&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;Redis6配置文件&quot;&gt;&lt;a href=&quot;#Redis6配置文件&quot; class=&quot;headerlink&quot; title=&quot;Redis6配置文件&quot;&gt;&lt;/a&gt;Redis6配置文件&lt;/h1&gt;&lt;figure class=&quot;highlight she</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Redis6入门学习(一)</title>
    <link href="https://luxiaobai.cn/2021/10/08/redis/Redis1/"/>
    <id>https://luxiaobai.cn/2021/10/08/redis/Redis1/</id>
    <published>2021-10-08T02:34:57.707Z</published>
    <updated>2021-10-11T02:51:03.663Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a><strong>NoSQL数据库</strong></h1><h2 id="NoSQL数据库-1"><a href="#NoSQL数据库-1" class="headerlink" title="NoSQL数据库"></a><strong>NoSQL数据库</strong></h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a><strong>概述</strong></h3><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，泛指非关系型的数据库。NoSQL 不依赖业务逻辑方式存储，而以简单的key-value模式存储。因此大大的增加了数据库的扩展能力。</p><ul><li>不遵循SQL标准。</li><li>不支持ACID。(事务的4个特征:原子性、一致性、隔离性和持久性)</li><li>远超于SQL的性能。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h4><ul><li>对数据高并发的读写</li><li>海量数据的读写</li><li>对数据高可扩展性的</li></ul><h4 id="不适用的场景"><a href="#不适用的场景" class="headerlink" title="不适用的场景"></a><strong>不适用的场景</strong></h4><ul><li>需要事务支持</li><li>基于sql的结构化查询存储，处理复杂的关系,需要即席查询。</li></ul><blockquote><p>（用不着sql的和用了sql也不行的情况，请考虑用NoSql）</p></blockquote><h4 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a><strong>Memcache</strong></h4><ul><li>很早出现的NoSql数据库</li><li>数据都在内存中，一般不持久化</li><li>支持简单的key-value模式，支持类型单一</li><li>一般是作为缓存数据库辅助持久化的数据库</li></ul><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h4><ul><li>几乎覆盖了Memcached的绝大部分功能</li><li>数据都在内存中，支持持久化，主要用作备份恢复</li><li>除了支持简单的key-value模式，还支持多种数据结构的存储，比如 list、set、hash、zset等。</li><li>一般是作为缓存数据库辅助持久化的数据库</li></ul><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a><strong>MongoDB</strong></h4><ul><li>高性能、开源、模式自由(schema  free)的文档型数据库</li><li>数据都在内存中， 如果内存不足，把不常用的数据保存到硬盘</li><li>虽然是key-value模式，但是对value（尤其是json）提供了丰富的查询功能</li><li>支持二进制数据及大型对象</li><li>可以根据数据的特点替代RDBMS ，成为独立的数据库。或者配合RDBMS，存储特定的数据</li></ul><h3 id="行式存储数据库"><a href="#行式存储数据库" class="headerlink" title="行式存储数据库"></a><strong>行式存储数据库</strong></h3><p><img src="http://qiliu.luxiaobai.cn/img/redisrow.png" alt="行式存储"></p><h3 id="列式存储数据库"><a href="#列式存储数据库" class="headerlink" title="列式存储数据库"></a>列式存储数据库</h3><p><img src="http://qiliu.luxiaobai.cn/img/rediscol.png" alt="列式数据库"></p><h3 id="图关系型数据库"><a href="#图关系型数据库" class="headerlink" title="图关系型数据库"></a>图关系型数据库</h3><p>主要应用：社会关系，公共交通网络，地图及网络拓谱(n*(n-1)/2)</p><p><img src="http://qiliu.luxiaobai.cn/img/redisimg.png" alt="图关系型"></p><h3 id="Cassandra-kəˈsaendrə"><a href="#Cassandra-kəˈsaendrə" class="headerlink" title="Cassandra[kəˈsændrə]"></a><strong>Cassandra[kəˈsændrə]</strong></h3><p>Apache Cassandra是一款免费的开源NoSQL数据库，其设计目的在于管理由大量商用服务器构建起来的庞大集群上的海量数据集(数据量通常达到PB级别)。在众多显著特性当中，Cassandra最为卓越的长处是对写入及读取操作进行规模调整，而且其不强调主集群的设计思路能够以相对直观的方式简化各集群的创建与扩展流程。</p><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a><strong>Hbase</strong></h3><p>HBase是Hadoop项目中的数据库。它用于需要对大量的数据进行随机、实时的读写操作的场景中。</p><p>HBase的目标就是处理数据量非常庞大的表，可以用普通的计算机处理超过10亿行数据，还可处理有数百万列元素的数据表。</p><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a><strong>介绍</strong></h2><ul><li>Redis是一个开源的key-value存储系统。</li><li>和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。</li><li>这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。</li><li>在此基础上，Redis支持各种不同方式的排序。</li><li>与memcached一样，为了保证效率，数据都是缓存在内存中。</li><li>区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件。</li><li>并且在此基础上实现了master-slave(主从)同步</li></ul><h2 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a><strong>适用场景</strong></h2><h3 id="配合关系型数据库做高速缓存"><a href="#配合关系型数据库做高速缓存" class="headerlink" title="配合关系型数据库做高速缓存"></a><strong>配合关系型数据库做高速缓存</strong></h3><ul><li>高频次，热门访问的数据，降低数据库IO</li><li>分布式架构，做session共享</li></ul><h3 id="多样的数据结构存储持久化数据"><a href="#多样的数据结构存储持久化数据" class="headerlink" title="多样的数据结构存储持久化数据"></a><strong>多样的数据结构存储持久化数据</strong></h3><p><img src="http://qiliu.luxiaobai.cn/img/redis1.png" alt="redis1"></p><h2 id="Ubuntu安装Redis"><a href="#Ubuntu安装Redis" class="headerlink" title="Ubuntu安装Redis"></a><strong>Ubuntu安装Redis</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装</span></span><br><span class="line">sudo apt update</span><br><span class="line">sudo apt install redis-server</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">启动</span></span><br><span class="line">redis-server</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看redis是否启动</span></span><br><span class="line">redis-cli</span><br><span class="line">root@iZbp13941xpzjmefjge9chZ:~# redis-cli</span><br><span class="line">127.0.0.1:6379&gt; auth &quot;lxb991209&quot;</span><br><span class="line">127.0.0.1:6379&gt; ping</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure><h3 id="Ubuntu默认目录-usr-bin"><a href="#Ubuntu默认目录-usr-bin" class="headerlink" title="Ubuntu默认目录 /usr/bin"></a><strong>Ubuntu默认目录 /usr/bin</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark:性能测试工具，可以在自己本机运行，看看自己本机性能如何</span><br><span class="line">redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲 </span><br><span class="line">redis-check-dump：修复有问题的dump.rdb文件</span><br><span class="line">redis-sentinel：Redis集群使用</span><br><span class="line">redis-server：Redis服务器启动命令</span><br><span class="line">redis-cli：客户端，操作入口</span><br></pre></td></tr></table></figure><h4 id="前台启动-不推荐"><a href="#前台启动-不推荐" class="headerlink" title="前台启动(不推荐)"></a><strong>前台启动(不推荐)</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure><h4 id="后台启动-推荐"><a href="#后台启动-推荐" class="headerlink" title="后台启动(推荐)"></a>后台启动(推荐)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp -r redis.conf /etc/redis.conf</span><br><span class="line">redis-server /etc/redis.conf</span><br></pre></td></tr></table></figure><h3 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">默认端口6379</span><br><span class="line">默认16个数据库，类似数组下标从0开始，初始默认使用0号库</span><br><span class="line">使用命令 select   &lt;dbid&gt;来切换数据库。如: select 8</span><br><span class="line">统一密码管理，所有库同样密码。</span><br><span class="line">dbsize查看当前数据库的key的数量</span><br><span class="line">flushdb清空当前库</span><br><span class="line">flushall通杀全部库</span><br></pre></td></tr></table></figure><p>Redis是<strong>单线程+多路IO复用技术</strong></p><p>多路复用是指<strong>使用一个线程来检查多个文件描述符（Socket）的就绪状态</strong>，比如调用select和poll函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）</p><p><strong>串行  vs  多线程+锁（memcached） vs  单线程+多路IO复用(Redis)</strong></p><p>（</p><p>与Memcache三点不同: </p><ul><li>支持多数据类型</li><li>支持持久化</li><li>单线程+多路IO复用</li></ul><p>）</p><h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><h2 id="Redis键-Key"><a href="#Redis键-Key" class="headerlink" title="Redis键(Key)"></a>Redis键(Key)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">keys *                ==查看当前库所有key==    (匹配：keys *1)</span><br><span class="line">exists key            判断某个key是否存在</span><br><span class="line">type key              查看你的key是什么类型</span><br><span class="line">del key               删除指定的key数据</span><br><span class="line">unlink key            根据value选择非阻塞删除 仅将keys从keyspace     元数据中删除，真正的删除会在后续异步操作。</span><br><span class="line">expire key 10         10秒钟：为给定的key设置过期时间</span><br><span class="line">ttl key               查看还有多少秒过期，-1表示永不过期，-2表示已过期</span><br><span class="line"> </span><br><span class="line">select                命令切换数据库</span><br><span class="line">dbsize               查看当前数据库的key的数量</span><br><span class="line">flushdb              清空当前库</span><br><span class="line">flushall             通杀全部库</span><br></pre></td></tr></table></figure><h2 id="Redis字符串-String"><a href="#Redis字符串-String" class="headerlink" title="Redis字符串(String)"></a><strong>Redis字符串(String)</strong></h2><ul><li>String是Redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value。</li><li>String类型是二进制安全的。意味着Redis的string可以包含任何数据。比如jpg图片或者序列化的对象。</li><li>String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M</li></ul><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">set &lt;key&gt;&lt;value&gt;      添加键值对</span><br><span class="line">    *NX：当数据库中key不存在时，可以将key-value添加数据库</span><br><span class="line">    *XX：当数据库中key存在时，可以将key-value添加数据库，与NX参数互斥</span><br><span class="line">    *EX：key的超时秒数</span><br><span class="line">    *PX：key的超时毫秒数，与EX互斥</span><br><span class="line"></span><br><span class="line">get     &lt;key&gt;             查询对应键值</span><br><span class="line">append  &lt;key&gt;&lt;value&gt;      将给定的&lt;value&gt; 追加到原值的末尾</span><br><span class="line">strlen  &lt;key&gt;             获得值的长度</span><br><span class="line">setnx  &lt;key&gt;&lt;value&gt;      只有在 key 不存在时    设置 key 的值</span><br><span class="line"> </span><br><span class="line">incr  &lt;key&gt;             将 key 中储存的数字值增1,只能对数字值操作，如果为空，新增值为1</span><br><span class="line">decr  &lt;key&gt;             将 key 中储存的数字值减1,只能对数字值操作，如果为空，新增值为-1</span><br><span class="line">incrby / decrby  &lt;key&gt; &lt;步长&gt;   将 key 中储存的数字值增减。自定义步长。        </span><br><span class="line">mset  &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  .....    同时设置一个或多个 key-value对  </span><br><span class="line">mget  &lt;key1&gt;&lt;key2&gt;&lt;key3&gt; .....               同时获取一个或多个 value  </span><br><span class="line">msetnx &lt;key1&gt;&lt;value1&gt;&lt;key2&gt;&lt;value2&gt;  .....   同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在。</span><br><span class="line">原子性，有一个失败则都失败</span><br><span class="line"> </span><br><span class="line">getrange  &lt;key&gt;&lt;起始位置&gt;&lt;结束位置&gt;             获得值的范围，类似java中的substring，前包，后包</span><br><span class="line">setrange  &lt;key&gt;&lt;起始位置&gt;&lt;value&gt;               用 &lt;value&gt;  覆写&lt;key&gt;所储存的字符串值，从&lt;起始位置&gt;开始(索引从0开始)。</span><br><span class="line"> </span><br><span class="line">setex  &lt;key&gt;&lt;过期时间&gt;&lt;value&gt;                  设置键值的同时，设置过期时间，单位秒。</span><br><span class="line">getset &lt;key&gt;&lt;value&gt;                           以新换旧，设置了新值同时获得旧值。</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><strong>incr key :对存储在指定key的数值执行原子的加1操作</strong></p><p>所谓原子操作是指不会被线程调度机制打断的操作；</p><p>这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。</p><p>（1）在单线程中， 能够在单条指令中完成的操作都可以认为是”原子操作”，因为中断只能发生于指令之间。</p><p>（2）在多线程中，不能被其它进程（线程）打断的操作就叫原子操作。</p><p>Redis单命令的原子性主要得益于Redis的单线程</p></blockquote><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>String的数据结构为简单动态字符串(Simple Dynamic String,缩写SDS)。是可以修改的字符串，内部结构实现上类似于Java的ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配.</p><p><img src="http://qiliu.luxiaobai.cn/img/redisstring.png" alt="redisstring"></p><p>内部为当前字符串实际分配的空间capacity一般要高于实际字符串长度len。<strong>当字符串长度小于1M时，扩容都是加倍现有的空间，如果超过1M，扩容时一次只会多扩1M的空间</strong>。需要注意的是字符串最大长度为512M。</p><h2 id="Redis列表-List"><a href="#Redis列表-List" class="headerlink" title="Redis列表(List)"></a>Redis列表(List)</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h3><p>单键多值</p><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。<strong>它的底层实际是个双向链表，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</strong></p><p><img src="http://qiliu.luxiaobai.cn/img/redislist.png" alt="redislist"></p><h3 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">lpush/rpush  &lt;key&gt;&lt;value1&gt;&lt;value2&gt;&lt;value3&gt; .... 从左边/右边插入一个或多个值。</span><br><span class="line">lpop/rpop  &lt;key&gt;            从左边/右边吐出一个值。值在键在，值光键亡。</span><br><span class="line">rpoplpush  &lt;key1&gt;&lt;key2&gt;     从&lt;key1&gt;列表右边吐出一个值，插到&lt;key2&gt;列表左边。</span><br><span class="line">lrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;     按照索引下标获得元素(从左到右)</span><br><span class="line">lrange mylist 0 -1             0左边第一个，-1右边第一个，（0-1表示获取所有）</span><br><span class="line">lindex &lt;key&gt;&lt;index&gt;          按照索引下标获得元素(从左到右)</span><br><span class="line">llen &lt;key&gt;                    获得列表长度</span><br><span class="line">linsert &lt;key&gt;  before/after &lt;value&gt;&lt;newvalue&gt;     在&lt;value&gt;的后面插入&lt;newvalue&gt;插入值</span><br><span class="line">lrem &lt;key&gt;&lt;n&gt;&lt;value&gt;                         从左边删除n个value(从左到右)</span><br><span class="line">lset&lt;key&gt;&lt;index&gt;&lt;value&gt;                    将列表key下标为index的值替换成value</span><br></pre></td></tr></table></figure><h3 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h3><p>List的数据结构为==<strong>快速链表quickList</strong>。==</p><p>首先在<strong>列表元素较少的情况下会使用一块连续的内存存储</strong>，这个结构是<strong>ziplist</strong>，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当<strong>数据量比较多的时候才会改成quicklist</strong>。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是int类型的数据，结构上还需要两个额外的指针prev和next。</p><p><img src="http://qiliu.luxiaobai.cn/img/redislist1.png" alt="redislist1"></p><p>Redis将链表和ziplist结合起来组成了quicklist。也就是将多个ziplist使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p><h2 id="Redis集合-Set"><a href="#Redis集合-Set" class="headerlink" title="Redis集合(Set)"></a>Redis集合(Set)</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于<strong>set是可以自动排重</strong>的，set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。Redis的Set是string类型的无序集合。它底层其实是一个value为null的hash表，所以添加，删除，查找的**复杂度都是O(1)**。</p><p>一个算法，随着数据的增加，执行时间的长短，如果是O(1)，数据增加，查找数据的时间不变</p><h3 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sadd &lt;key&gt;&lt;value1&gt;&lt;value2&gt; .....   将一个或多个 member 元素加入到集合 key 中，已经存在的 member 元素将被忽略</span><br><span class="line">smembers &lt;key&gt;                     取出该集合的所有值。</span><br><span class="line">sismember &lt;key&gt;&lt;value&gt;             判断集合&lt;key&gt;是否为含有该&lt;value&gt;值，有1，没有0</span><br><span class="line">scard&lt;key&gt;                         返回该集合的元素个数。</span><br><span class="line">srem &lt;key&gt;&lt;value1&gt;&lt;value2&gt; ....    删除集合中的某个元素。</span><br><span class="line">spop &lt;key&gt;                         随机从该集合中吐出一个值。</span><br><span class="line">srandmember &lt;key&gt;&lt;n&gt;               随机从该集合中取出n个值。不会从集合中删除 。</span><br><span class="line">smove &lt;source&gt;&lt;destination&gt;value        把集合中一个值从一个集合移动到另一个集合</span><br><span class="line">sinter &lt;key1&gt;&lt;key2&gt;                        返回两个集合的交集元素。</span><br><span class="line">sunion &lt;key1&gt;&lt;key2&gt;                        返回两个集合的并集元素。</span><br><span class="line">sdiff &lt;key1&gt;&lt;key2&gt;                返回两个集合的差集元素(key1中的，不包含key2中的)</span><br></pre></td></tr></table></figure><h3 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h3><p>Set数据结构是dict字典，字典是用哈希表实现的。Java中HashSet的内部实现使用的是HashMap，只不过所有的value都指向同一个对象。Redis的set结构也是一样，它的内部也使用hash结构，所有的value都指向同一个内部值。</p><h2 id="Redis哈希-hash"><a href="#Redis哈希-hash" class="headerlink" title="Redis哈希(hash)"></a>Redis哈希(hash)</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>Redis hash 是一个键值对集合。</p><p>Redis hash是一个string类型的<strong>field</strong>和<strong>value</strong>的映射表，hash特别适合用于存储对象。</p><p>类似Java里面的Map&lt;String,Object&gt;</p><p>用户ID为查找的key，存储的value用户对象包含姓名，年龄，生日等信息，如果用普通的key/value结构来存储</p><p><img src="http://qiliu.luxiaobai.cn/img/redishash.png" alt="redishash"></p><p><img src="http://qiliu.luxiaobai.cn/img/redishash2.png" alt="redishash2"></p><p>通过 <strong>key(用户ID) + field(属性标签)</strong> 就可以操作对应属性数据了，既不需要重复存储数据，也不会带来序列化和并发修改控制的问题</p><h3 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hset &lt;key&gt;&lt;field&gt;&lt;value&gt;         给&lt;key&gt;集合中的&lt;field&gt;键赋值&lt;value&gt;</span><br><span class="line">hget &lt;key1&gt;&lt;field&gt;                从&lt;key1&gt;集合&lt;field&gt;取出 value</span><br><span class="line">hmset &lt;key1&gt;&lt;field1&gt;&lt;value1&gt;&lt;field2&gt;&lt;value2&gt;...         批量设置hash的值</span><br><span class="line">hexists&lt;key1&gt;&lt;field&gt;                        查看哈希表 key 中，给定域 field 是否存在。</span><br><span class="line">hkeys &lt;key&gt;                                列出该hash集合的所有field</span><br><span class="line">hvals &lt;key&gt;                                列出该hash集合的所有value</span><br><span class="line">hincrby &lt;key&gt;&lt;field&gt;&lt;increment&gt;           为哈希表 key 中的域 field 的值加上增量 1   -1</span><br><span class="line">hsetnx &lt;key&gt;&lt;field&gt;&lt;value&gt;                将哈希表 key 中的域 field 的值设置为 value ，当且仅当域 field 不存在 .</span><br></pre></td></tr></table></figure><h3 id="数据结构-3"><a href="#数据结构-3" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>Hash类型对应的数据结构是两种：ziplist（压缩列表），hashtable（哈希表）。当field-value长度较短且个数较少时，使用ziplist，否则使用hashtable。</p><h2 id="Redis有序集合-Zset"><a href="#Redis有序集合-Zset" class="headerlink" title="Redis有序集合(Zset)"></a>Redis有序集合(Zset)</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>Redis有序集合zset与普通集合set非常相似，是一个<strong>没有重复元素</strong>的字符串集合。</p><p>不同之处是有序集合的每个成员都关联了一个<strong>评分（score</strong>）,这个评分（score）被用来按照从最低分到最高分的方式排序集合中的成员。集合的成员是唯一的，但是评分可以是重复了 。</p><p>因为元素是有序的, 所以你也可以很快的根据评分（score）或者次序（position）来获取一个范围的元素。</p><p>访问有序集合的中间元素也是非常快的,因此你能够使用有序集合作为一个没有重复成员的智能列表。</p><h3 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">zadd  &lt;key&gt;&lt;score1&gt;&lt;value1&gt;&lt;score2&gt;&lt;value2&gt;…        将一个或多个 member 元素及其 score 值加入到有序集 key 当中。</span><br><span class="line">zrange &lt;key&gt;&lt;start&gt;&lt;stop&gt;  [WITHSCORES]            返回有序集 key 中，下标在&lt;start&gt;&lt;stop&gt;之间的元素  带WITHSCORES，可以让分数一起和值返回到结果集。</span><br><span class="line">zrangebyscore key minmax [withscores] [limit offset count]       返回有序集 key 中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员。有序集成员按 score 值递增(从小到大)次序排列。</span><br><span class="line">zrevrangebyscore key maxmin [withscores] [limit offset count]    同上，改为从大到小排列。</span><br><span class="line">zincrby &lt;key&gt;&lt;increment&gt;&lt;value&gt;                    为元素的score加上增量</span><br><span class="line">zrem  &lt;key&gt;&lt;value&gt;                                 删除该集合下，指定值的元素</span><br><span class="line">zcount &lt;key&gt;&lt;min&gt;&lt;max&gt;                             统计该集合，分数区间内的元素个数</span><br><span class="line">zrank &lt;key&gt;&lt;value&gt;                                   返回该值在集合中的排名，从0开始。</span><br></pre></td></tr></table></figure><h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构"></a><strong>数据结构</strong></h3><p>SortedSet(zset)是Redis提供的一个非常特别的数据结构，一方面它等价于Java的数据结构Map&lt;String, Double&gt;，可以给每一个元素value赋予一个权重score，另一方面它又类似于TreeSet，内部的元素会按照权重score进行排序，可以得到每个元素的名次，还可以通过score的范围来获取元素的列表。</p><p>zset底层使用了两个数据结构</p><p>（1）hash，hash的作用就是关联元素value和权重score，保障元素value的唯一性，可以通过元素value找到相应的score值。</p><p>（2）跳跃表，跳跃表的目的在于给元素value排序，根据score的范围获取元素列表。</p><h2 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>有序集合在生活中比较常见，例如根据成绩对学生排名，根据得分对玩家排名等。对于有序集合的底层实现，可以用数组、平衡树、链表等。数组不便元素的插入、删除；平衡树或红黑树虽然效率高但结构复杂；链表查询需要遍历所有效率低。Redis采用的是跳跃表。跳跃表效率堪比红黑树，实现远比红黑树简单。</p><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><p>对比有序链表和跳跃表，从链表中查询出51</p><p>（1） 有序链表</p><p><img src="http://qiliu.luxiaobai.cn/img/redis2.png" alt="redis2"></p><p>要查找值为51的元素，需要从第一个元素开始依次查找、比较才能找到。共需要6次比较。</p><p>（2） 跳跃表</p><p><img src="http://qiliu.luxiaobai.cn/img/redis3.png" alt="redis3"></p><p>从第2层开始，1节点比51节点小，向后比较。</p><p>21节点比51节点小，继续向后比较，后面就是NULL了，所以从21节点向下到第1层</p><p>在第1层，41节点比51节点小，继续向后，61节点比51节点大，所以从41向下</p><p>在第0层，51节点为要查找的节点，节点被找到，共查找4次。</p><p>从此可以看出跳跃表比有序链表效率要高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;NoSQL数据库&quot;&gt;&lt;a href=&quot;#NoSQL数据库&quot; class=&quot;headerlink&quot; title=&quot;NoSQL数据库&quot;&gt;&lt;/a&gt;&lt;strong&gt;NoSQL数据库&lt;/strong&gt;&lt;/h1&gt;&lt;h2 id=&quot;NoSQL数据库-1&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>全面了解Nginx如何配置</title>
    <link href="https://luxiaobai.cn/2021/10/06/nginx/"/>
    <id>https://luxiaobai.cn/2021/10/06/nginx/</id>
    <published>2021-10-06T13:01:24.000Z</published>
    <updated>2021-10-11T04:11:43.152Z</updated>
    
    <content type="html"><![CDATA[<p>[toc]</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx是一个高性能的HTTP和反向代理Web服务器.同时也提供了IMAP/POP3/SMTP服务.占有内存少、并发能力强。</p><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a><strong>正向代理</strong></h3><p>在客户端（浏览器）配置代理服务器，通过代理服务器进行互联网访问</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a><strong>反向代理</strong></h3><p>客户端对代理是无感知的，不需要任何配置就可以访问。只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。</p><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>并发请求时，将请求分发到多个服务器上，将负载分发到不同的服务器</p><h3 id="动静分离"><a href="#动静分离" class="headerlink" title="动静分离"></a>动静分离</h3><p>为加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 </p><h1 id="Nginx配置文件"><a href="#Nginx配置文件" class="headerlink" title="Nginx配置文件"></a>Nginx配置文件</h1><h2 id="第一部分-全局块"><a href="#第一部分-全局块" class="headerlink" title="第一部分: 全局块"></a>第一部分: 全局块</h2><p>从配置文件开始到events块之间的内容，主要会设置一些影响Nginx服务器整体运行的配置指令，主要包括：配置运行Nginx服务器的用户（组）、运行生成的worker process数、进程PID存放路径、日志存放路径和类型以及配置文件的引入等。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span> <span class="number">1</span>; <span class="comment">##worker_processes值越大，可以支持的并发处理量也越多</span></span><br></pre></td></tr></table></figure><h2 id="第二部分-events"><a href="#第二部分-events" class="headerlink" title="第二部分: events"></a>第二部分: events</h2><p>主要影响Nginx服务器与用户的网络连接，常用设置包括是否开启对多workprocess下的网络连接进行序列化，是否允许同时接收多个网络连接，选取那种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">events</span> &#123;</span><br><span class="line"><span class="attribute">worker_connections</span> <span class="number">768</span>; <span class="comment">##支持的最大连接数</span></span><br><span class="line"><span class="comment"># multi_accept on;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第三部分-http块"><a href="#第三部分-http块" class="headerlink" title="第三部分:http块"></a>第三部分:http块</h2><p>http块包括：http块和server块</p><p><strong>http块： 配置指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。</strong> </p><p><strong>server块：</strong> </p><ol><li>全局server块：本虚拟机主机的监听配置和本虚拟机主机的名称或IP配置</li><li>location块：一个server块可以配置多个location块。主要作用是基于Nginx服务器接收到的请求字符串（例如server_name/uri-string)，<strong>对虚拟主机名称（也可以是IP别名）之外的字符串（例如前面的/uri-string)进行匹配，对特定的请求进行处理</strong>。<strong>地址定向、数据缓存和应答控制</strong>等功能，以及<strong>第三方模块的配置</strong>也在这里进行。</li></ol><h1 id="Nginx源码安装"><a href="#Nginx源码安装" class="headerlink" title="Nginx源码安装"></a>Nginx源码安装</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#CentOS 安装</span></span></span><br><span class="line">yum -y install gcc</span><br><span class="line">yum install -y pcre pcre-devel</span><br><span class="line">yum install -y zlib zlib-devel</span><br><span class="line">yum install -y openssl openssl-devel</span><br><span class="line">wget http://nginx.org/download/nginx-1.9.9.tar.gz</span><br><span class="line">tar -zxvf  nginx-1.9.9.tar.gz</span><br><span class="line">cd nginx-1.9.9</span><br><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:如果连接不上，检查阿里云安全组是否开放端口，或者服务器防火墙是否开放端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">开启</span></span><br><span class="line">service firewalld start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启</span></span><br><span class="line">service firewalld restart</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">关闭</span></span><br><span class="line">service firewalld stop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看防火墙规则</span></span><br><span class="line">firewall-cmd --list-all</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查询端口是否开放</span></span><br><span class="line">firewall-cmd --query-port=8080/tcp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">开放80端口</span></span><br><span class="line">firewall-cmd --permanent --add-port=80/tcp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">移除端口</span></span><br><span class="line">firewall-cmd --permanent --remove-port=8080/tcp</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启防火墙（修改配置后要重启防火墙)</span></span><br><span class="line">firewall-cmd --reload</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#参数解释</span></span></span><br><span class="line">firwall-cmd:是Linux提供的操作firewall的一个工具：</span><br><span class="line">    --permanent：表示设置为持久</span><br><span class="line">    --add-port：标识添加的端口</span><br></pre></td></tr></table></figure><h1 id="Nginx功能模块配置"><a href="#Nginx功能模块配置" class="headerlink" title="Nginx功能模块配置"></a>Nginx功能模块配置</h1><h2 id="反向代理-1"><a href="#反向代理-1" class="headerlink" title="反向代理"></a>反向代理</h2><h3 id="请求转发配置"><a href="#请求转发配置" class="headerlink" title="请求转发配置"></a>请求转发配置</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">8080</span>;</span><br><span class="line">  server_name: 192.168.17.219;</span><br><span class="line">  <span class="attribute">root</span> /home/project/DIANBoard/build;</span><br><span class="line">  <span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8888;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用Nginx反向代理，根据访问的路径跳转到不同端口的服务中，Nginx监听9001</p><p>访问<a href="http://127.0.0.1:9001/edu/">http://127.0.0.1:9001/edu/</a> 直接跳转到127.0.0.1:8080</p><p>访问<a href="http://127.0.0.1:9001/vod/">http://127.0.0.1:9001/vod/</a> 直接跳转到127.0.0.1:8081</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">listen</span> <span class="number">9091</span>;</span><br><span class="line">  <span class="attribute">server_name</span> localhost;</span><br><span class="line">  //允许cros跨域访问</span><br><span class="line">  <span class="attribute">add_header</span> <span class="string">&#x27;Access-Control-Allow-Origin&#x27;</span> <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">   <span class="comment">#proxy_redirect default;</span></span><br><span class="line">      <span class="comment">#跟代理服务器连接的超时时间，必须留意这个time out时间不能超过75秒，当一台服务器当掉时，过10秒转发到另外一台服务器。</span></span><br><span class="line">   <span class="attribute">proxy_connect_timeout</span> <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="attribute">location</span> <span class="regexp">~ /edu/</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="attribute">location</span> <span class="regexp">~ /vod/</span> &#123;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://127.0.0.1:8081;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="location指令说明"><a href="#location指令说明" class="headerlink" title="location指令说明"></a>location指令说明</h4><p>用于匹配URL</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location [ = | ~ | ~* | ^~] uri &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>=：用于不含正则表达式的URI前，要求请求字符串与URI严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求</li><li>~：用于表示URI包含正则表达式，并且区分大小写。</li><li>~*：用于表示URI包含正则表达式，并且不区分大小写</li><li>*~：用于不含正则表达式的URI前，要求Nginx服务器找到标识URI和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则URI和请求字符串做匹配。</li></ol><p>*<em>注意：如果URI包含正则表达式，则必须要有~ 或者 ~<em>标识。</em></em></p><h2 id="负载均衡-1"><a href="#负载均衡-1" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">  ...</span><br><span class="line">    <span class="attribute">upstream</span> myserver&#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">121.199.76.44:8080</span>;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">121.199.76.44:8081</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  server&#123;</span><br><span class="line">    <span class="attribute">listen</span> <span class="number">7777</span>;</span><br><span class="line">    <span class="attribute">server_name</span> localhost;</span><br><span class="line">    <span class="attribute">root</span> /myproject/build;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">      ....</span><br><span class="line">      <span class="attribute">proxy_pass</span> http://myserver;</span><br><span class="line">      <span class="attribute">proxy_connection_timeout</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。"><a href="#1-轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。" class="headerlink" title="1.轮询（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。"></a>1.<strong>轮询</strong>（默认）：每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</h4><h4 id="2-weight：weight代表权重默认为1，权重越高被分配的客户端越多。"><a href="#2-weight：weight代表权重默认为1，权重越高被分配的客户端越多。" class="headerlink" title="2.weight：weight代表权重默认为1，权重越高被分配的客户端越多。"></a>2.<strong>weight</strong>：weight代表权重默认为1，权重越高被分配的客户端越多。</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myserver&#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">121.199.76.44:8080</span> weight=<span class="number">1</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">121.199.76.44:8081</span> weight=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-ip-hash：每个请求按访问IP的hash结果分配，这样每个请求固定访问一个后端服务器。可以解决session的问题。"><a href="#3-ip-hash：每个请求按访问IP的hash结果分配，这样每个请求固定访问一个后端服务器。可以解决session的问题。" class="headerlink" title="3.ip_hash：每个请求按访问IP的hash结果分配，这样每个请求固定访问一个后端服务器。可以解决session的问题。"></a>3.<strong>ip_hash</strong>：每个请求按访问IP的hash结果分配，这样每个请求固定访问一个后端服务器。可以解决session的问题。</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myserver&#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">121.199.76.44:8080</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">121.199.76.44:8081</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。"><a href="#4-fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。" class="headerlink" title="4.fair（第三方）：按后端服务器的响应时间来分配请求，响应时间短的优先分配。"></a>4.<strong>fair（第三方）</strong>：按后端服务器的响应时间来分配请求，响应时间短的优先分配。</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">upstream</span> myserver&#123;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">121.199.76.44</span>;</span><br><span class="line">  <span class="attribute">server</span> <span class="number">121.199.76.44</span>;</span><br><span class="line">  fair;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动静分离-1"><a href="#动静分离-1" class="headerlink" title="动静分离"></a>动静分离</h2><p>将动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx处理静态页面，Tomcat处理动态页面。</p><p>动静分离实现角度：</p><ul><li>纯粹把静态文件独立成单独的域名，放在独立的服务器上</li><li>动态和静态文件混合在一起发布，通过Nginx来分开。</li></ul><p>通过location指定不同的后缀名实现不同的请求转发。通过expires参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。</p><p>Expires：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用Expires来缓存），3d，表示3天之内访问这个URL，发送一个请求，比对服务器改文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304， 如果有修改，则直接从服务器重新下载，返回状态码200。</p><p><img src="http://qiliu.luxiaobai.cn/img/%E6%88%AA%E5%9B%BE.png" alt="截图"></p><p>创建data目录，分别放data/a.html和image/1.jpeg</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> /www/ &#123;</span><br><span class="line">    <span class="attribute">root</span> /data/;</span><br><span class="line">    <span class="attribute">index</span> index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> /image/ &#123;</span><br><span class="line">    <span class="attribute">root</span> /data/;</span><br><span class="line">    <span class="attribute">autoindex</span> <span class="literal">on</span>; <span class="comment">#列出当前文件中的内容 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx限流"><a href="#Nginx限流" class="headerlink" title="Nginx限流"></a>Nginx限流</h2><h3 id="限制访问评率-正常流量"><a href="#限制访问评率-正常流量" class="headerlink" title="限制访问评率(正常流量)"></a><strong>限制访问评率(正常流量)</strong></h3><p>采用 ngx_http_limit_req_module模块来限制请求的访问频率，基于漏桶算法原理实现</p><p>使用 nginx limit_req_zone 和 limit_req 两个指令，限制单个IP的请求处理速率</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">limit_req_zone</span> $binary_remote_addr zone=serviceRateLimit:<span class="number">10m</span> rate=10r/s  //每秒最多处理<span class="number">10</span>个请求</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=servicelRateLimit;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://upstream_clusterl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>语法:limit_req_zone key zone rate</strong></p><ul><li><strong>key</strong>:定义限流对象,binary_remote_addr是一种key,表示基于remote_addr(客户端IP)来做限流,binary_的目的是压缩内存占用量</li><li><strong>zone</strong>:定义共享内存区来存储访问信息， myRateLimit:10m 表示一个大小为10M，名字为myRateLimit的内存区域。1M能存储16000 IP地址的访问信息，10M可以存储16W IP地址访问信息。</li><li><strong>rate</strong>:用于设置最大访问速率，rate=10r/s 表示每秒最多处理10个请求。Nginx 实际上以毫秒为粒度来跟踪请求信息，因此 10r/s 实际上是限制：每100毫秒处理一个请求。这意味着，自上一个请求处理完后，若后续100毫秒内又有请求到达，将拒绝处理该请求</li></ul><h3 id="限制并发连接数-突发流量"><a href="#限制并发连接数-突发流量" class="headerlink" title="限制并发连接数(突发流量)"></a><strong>限制并发连接数(突发流量)</strong></h3><p>按上面的配置在流量突然增大时，超出的请求将被拒绝，无法处理突发流量，那么在处理突发流量的时候，该怎么处理呢？Nginx提供了 burst 参数来解决突发流量的问题，并结合 nodelay 参数一起使用。burst 译为突发、爆发，表示在超过设定的处理速率后能额外处理的请求数。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">limit_req_zone</span> $binary_remote_addr zone=serviceRateLimit:<span class="number">10m</span> rate=10r/s  //每秒最多处理<span class="number">10</span>个请求</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">limit_req</span> zone=servicelRateLimit burst=<span class="number">20</span> nodelay;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://upstream_clusterl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>burst=20 nodelay表示这20个请求立马处理，不能延迟，相当于特事特办。不过，即使这20个突发请求立马处理结束，后续来了请求也不会立马处理。burst=20 相当于缓存队列中占了20个坑，即使请求被处理了，这20个位置这只能按 100ms一个来释放。这就达到了速率稳定，但突然流量也能正常处理的效果。</p><h3 id="限制并发连接数"><a href="#限制并发连接数" class="headerlink" title="限制并发连接数"></a><strong>限制并发连接数</strong></h3><p>ngx_http_limit_conn_module模块提供了对资源连接数进行限制的功能，使用 limit_conn_zone 和 limit_conn 两个指令</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line">    <span class="attribute">limit_conn_zone</span> $binary_remote_addr zone=perip:<span class="number">10m</span>;</span><br><span class="line">    <span class="attribute">limit_conn_zone</span> $server_name zone=perserver:<span class="number">10m</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">limit_conn</span> perip <span class="number">20</span>;     //限制单个IP同时最多能持有10连接</span><br><span class="line">    <span class="attribute">limit_conn</span> perserver <span class="number">100</span>; //限制server的最大连接数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>limit_conn perip 20：对应的key是 $binary_remote_addr，表示限制单个IP同时最多能持有20个连接。</li><li>limit_conn perserver 100：对应的key是 $server_name，表示虚拟主机(server) 同时能处理并发连接的总数。注意，只有当 request header 被后端server处理后，这个连接才进行计数。</li></ul><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><h3 id="1、浏览器缓存-静态资源缓存用expire"><a href="#1、浏览器缓存-静态资源缓存用expire" class="headerlink" title="1、浏览器缓存,静态资源缓存用expire"></a><strong>1、浏览器缓存,静态资源缓存用expire</strong></h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(?:jpg|jpeg|gif|png|ico|cur|gz|svg|mp4|ogg|ogv|webm)$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">location</span> <span class="regexp">~ .*\.(?:js|css)$</span> &#123;</span><br><span class="line">    <span class="attribute">expires</span> <span class="number">7d</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、代理层缓存"><a href="#2、代理层缓存" class="headerlink" title="2、代理层缓存"></a>2、代理层缓存</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">proxy_cache_path</span> /data/cache/nginx/ levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache:<span class="number">512m</span> inactive = <span class="number">1d</span> max_size=<span class="number">8g</span>;</span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ \.(htm|html)?$</span> &#123;</span><br><span class="line">        <span class="attribute">proxy_cache</span> cache;</span><br><span class="line">        <span class="attribute">proxy_cache_key</span> $uri$is_args$args;    //以此变量值做HASH,作为<span class="attribute">KEY</span></span><br><span class="line">        add_header X-Cache $upstream_cache_status;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> <span class="number">200</span> <span class="number">10m</span>;</span><br><span class="line">        <span class="attribute">proxy_cache_valid</span> any <span class="number">1m</span>;</span><br><span class="line">        <span class="attribute">proxy_pass</span> http://real_server;</span><br><span class="line">       <span class="attribute">proxy_redirect</span> <span class="literal">off</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attribute">location</span> <span class="regexp">~ .*\.(gif|jpg|jpeg|bmp|png|ico|txt|js|css)<span class="variable">$&#123;</span></span></span><br><span class="line"><span class="variable"><span class="regexp">        root /data/webapps/edc;</span></span></span><br><span class="line"><span class="variable"><span class="regexp">        expires 3d;</span></span></span><br><span class="line"><span class="variable"><span class="regexp">        add_header Static Nginx-Proxy;</span></span></span><br><span class="line"><span class="variable"><span class="regexp">    &#125;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="黑白名单"><a href="#黑白名单" class="headerlink" title="黑白名单"></a>黑白名单</h2><h3 id="1、不限流白名单"><a href="#1、不限流白名单" class="headerlink" title="1、不限流白名单"></a>1、不限流白名单</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">geo</span> $limit &#123;</span><br><span class="line">    122.16.11.0/24 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">map</span> $limit $limit_key&#123;</span><br><span class="line">    1 $binary_remote_addr;</span><br><span class="line">    0 &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">limit_req_zone</span> $limit_key zone=mylimit:<span class="number">10m</span> rate=1r/s;</span><br><span class="line"></span><br><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">limit_req</span> zone=mylimit burst=<span class="number">1</span> nodelay;</span><br><span class="line">    <span class="attribute">proxy_pass</span> http://serveic3Cluster;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、黑名单"><a href="#2、黑名单" class="headerlink" title="2、黑名单"></a>2、黑名单</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">    <span class="attribute">deny</span> <span class="number">10.52.119.21</span>;</span><br><span class="line">    <span class="attribute">deny</span> <span class="number">11.12.123.1</span>/<span class="number">24</span>;</span><br><span class="line">    <span class="attribute">allow</span> <span class="number">10.1.1.0</span>/<span class="number">16</span>;</span><br><span class="line">    <span class="attribute">allow</span> <span class="number">1001</span>:0dby::/<span class="number">32</span>;</span><br><span class="line">    <span class="attribute">deny</span> all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx配置高可用的集群"><a href="#Nginx配置高可用的集群" class="headerlink" title="Nginx配置高可用的集群"></a><strong>Nginx配置高可用的集群</strong></h2><p><img src="http://qiliu.luxiaobai.cn/img/%E9%AB%98%E5%8F%AF%E7%94%A8nginx%E9%9B%86%E7%BE%A4.png" alt="高可用nginx集群"></p><p><strong>Keepalived</strong></p><ul><li>工作原理：vrrp协议实现</li><li>工作方式：抢占式和非抢占式</li></ul><p>高可用：两台业务系统启动相同服务，如果有一台宕机，另一台自动接管，即高可用</p><p>安装配置keepalived：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#两条服务器安装</span></span><br><span class="line"><span class="attribute">yum</span> install keepalived -y</span><br><span class="line"></span><br><span class="line"><span class="comment">##Ubuntu 安装keepalived</span></span><br><span class="line">sudo apt-get install libssl-dev</span><br><span class="line">sudo apt-get install openssl</span><br><span class="line">sudo apt-get install libpopt-dev</span><br><span class="line">sudo apt-get install keepalived</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置keepalived.conf</span></span><br><span class="line">sudo vim /etc/keepalived/keepalived.conf</span><br><span class="line">global_defs &#123;   <span class="comment">#全局定义</span></span><br><span class="line">    <span class="section">notifaction_email</span> &#123;</span><br><span class="line">        1575018859@qq.<span class="attribute">com</span></span><br><span class="line">    &#125;</span><br><span class="line">    notification_email_from sns-lvs@gmail.com</span><br><span class="line">    smtp_server smtp.hysec.com</span><br><span class="line">    smtp_connection_timeout <span class="number">30</span></span><br><span class="line">    router_id nginx_master         <span class="comment">#设置Nginx master的ID，在一个网络应该是唯一的,访问到主机</span></span><br><span class="line">&#125;</span><br><span class="line">vrrp_script chk_http_port &#123;</span><br><span class="line">    <span class="attribute">script</span> <span class="string">&quot;/usr/local/src/check_nginx_pid.sh&quot;</span>   <span class="comment">##最后手动执行下次脚本，以确保此脚本能够正常执行</span></span><br><span class="line">    interval <span class="number">2</span>                                <span class="comment">##(检测脚本执行的间隔，单位是秒)</span></span><br><span class="line">    weight <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    <span class="attribute">state</span> MASTER              <span class="comment">#指定keepalived的角色，MASTER为主，BACKUP为备</span></span><br><span class="line">    interface eth0           <span class="comment">#当前进行vrrp通讯的网络接口卡（当前centos的网卡),使用 ifconfig查看</span></span><br><span class="line">    virtual_router_id <span class="number">66</span>         <span class="comment">#虚拟路由编号，主从要一致</span></span><br><span class="line">    priority  <span class="number">100</span>             <span class="comment">#优先级，数值越大，获取处理请求的优先级越高</span></span><br><span class="line">    advert_int  <span class="number">1</span>               <span class="comment">#检查间隔，默认为ls（vrrp组播周期秒数)</span></span><br><span class="line">    authentication &#123;</span><br><span class="line">        <span class="attribute">auth_type</span> PASS</span><br><span class="line">        auth_pass <span class="number">1111</span></span><br><span class="line">    &#125;</span><br><span class="line">    track_script&#123;</span><br><span class="line">        <span class="attribute">chk_http_port</span>           <span class="comment">#调用检测脚本</span></span><br><span class="line">    &#125;</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        121.199.76.44              <span class="comment">##定义虚拟IP（VIP），可多设，每行一个</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">##创建Nginx服务监控脚本/usr/local/nginx/check_nginx.sh（主从服务器一致）</span></span><br><span class="line"><span class="attribute">sudo</span> vim /usr/local/src/check_nginx_pid.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">A=`ps -C nginx --<span class="literal">no</span>-header |wc -l`</span><br><span class="line">if [ $A -eq <span class="number">0</span> ];<span class="attribute">then</span></span><br><span class="line">    <span class="comment">#/usr/local/nginx/sbin/nginx            #重启Nginx</span></span><br><span class="line">    sudo service nginx restart</span><br><span class="line">    if [ `ps -C nginx --<span class="literal">no</span>-header | wc -l` -eq <span class="number">0</span>];<span class="attribute">then</span>  <span class="comment">#Nginx重启失败，则停掉keepalived服务</span></span><br><span class="line">        killall keepalived</span><br><span class="line">    fi</span><br><span class="line">fi  </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"> </span><br><span class="line"> <span class="comment">###另外检测脚本</span></span><br><span class="line"> <span class="comment">#!/bin/sh</span></span><br><span class="line"> nginxpid=$(ps -C nginx --<span class="literal">no</span>-header|wc -l)</span><br><span class="line"> <span class="comment">#1.判断Nginx是否存活，如果不存活则尝试启动Nginx</span></span><br><span class="line"> if [$nginxpid -eq <span class="number">0</span> ];<span class="attribute">then</span></span><br><span class="line">     systemctl start nginx</span><br><span class="line">     sleep <span class="number">3</span></span><br><span class="line">     <span class="comment">#2.等待3秒后再次获取一次Nginx状态</span></span><br><span class="line">     nginxpid=$(ps -C nginx --<span class="literal">no</span>-header|wc -l)</span><br><span class="line">     <span class="comment">#3.再次进行判断,如Nginx还不存活则停止keepalived,让地址进行漂移,并退出脚本</span></span><br><span class="line">     if[$nginxpid -eq <span class="number">0</span>];<span class="attribute">then</span></span><br><span class="line">         systemctl stop keepalived</span><br><span class="line">     fi</span><br><span class="line"> fi  </span><br></pre></td></tr></table></figure><p>日志存放位置：/var/log/messages</p><p>程序目录：/etc/keepalived/keepalivd.conf</p><p> 启动nginx和keepalived</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start keepalived.service</span><br></pre></td></tr></table></figure><p>一个master和多个worker的好处</p><ol><li>可以使用nginx  -s reload 热部署,利用nginx进行热部署操作</li><li>每个worker是独立的进程,如果有其中的一个worker出现问题,其他worker独立的,继续进行争抢,实现请求过程,不会造成服务中断 </li><li>设置多少个worker ?worker数和服务器的cpu数相等时最为适宜的 </li></ol><p><strong>连接数worker_connection</strong></p><p>发送请求,占有worker的几个连接数:2个(静态)或者4个(动态)</p><p>nginx有一个master,  有4个worker,每个worker支持最大的连接数据1024,支持的最大并发数多少?</p><p>##普通的静态访问最大并发数是:worker_connections * worker_processes / 2,</p><p>##而如果是http作为反向代理,最大并发数:worker_connections * worker_processes / 4</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;[toc]&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;h2 id=&quot;Nginx&quot;&gt;&lt;a href=&quot;#Nginx&quot; class=&quot;headerlink&quot; title=&quot;Ng</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://luxiaobai.cn/2021/10/04/hello-world/"/>
    <id>https://luxiaobai.cn/2021/10/04/hello-world/</id>
    <published>2021-10-04T03:35:04.791Z</published>
    <updated>2021-10-11T02:58:11.794Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
